#!/usr/bin/env bash
#
# Secrets management for dotfiles
# Integration with pass (password store) and direnv for secure credential handling
#

# Secrets directory
SECRETS_DIR="${HOME}/.local/share/dotfiles-secrets"
PASS_REPO_NAME="dotfiles-secrets"

# Export for subshells
export SECRETS_DIR PASS_REPO_NAME

# ============================================================================
# SECRETS INITIALIZATION
# ============================================================================

# Initialize pass repository for dotfiles secrets
init_secrets() {
    log "Initializing secrets management..."

    # Check if pass is installed
    if ! command -v pass &>/dev/null; then
        error "pass is required for secrets management"
        error "Install with: pacman -S pass"
        return 1
    fi

    # Check if GPG is configured
    if ! gpg --list-keys &>/dev/null; then
        error "GPG key not found. Please set up GPG first:"
        error "  gpg --full-generate-key"
        return 1
    fi

    # Create secrets directory
    if [[ ! -d "$SECRETS_DIR" ]]; then
        mkdir -p "$SECRETS_DIR"
        log "Created secrets directory: $SECRETS_DIR"
    fi

    # Initialize pass repository if it doesn't exist
    local pass_path
    pass_path="${PASSWORD_STORE_DIR:-$HOME/.password-store}"

    if [[ ! -d "$pass_path/$PASS_REPO_NAME" ]]; then
        log "Initializing pass repository: $PASS_REPO_NAME"
        pass init "$PASS_REPO_NAME" || {
            error "Failed to initialize pass repository"
            return 1
        }
        success "Pass repository initialized"
    else
        log "Pass repository already exists: $PASS_REPO_NAME"
    fi

    # Create .gitignore in secrets directory
    cat > "$SECRETS_DIR/.gitignore" << 'EOF'
# Ignore all files except .gitignore
*
!.gitignore
EOF

    success "Secrets management initialized"
    log "Secrets directory: $SECRETS_DIR"
    log "Pass repository: $PASS_REPO_NAME"
}

# ============================================================================
# SECRET OPERATIONS
# ============================================================================

# Add a new secret
add_secret() {
    local secret_name="$1"
    local secret_value="${2:-}"

    if [[ -z "$secret_name" ]]; then
        error "Secret name is required"
        return 1
    fi

    local full_path="${PASS_REPO_NAME}/${secret_name}"

    log "Adding secret: $secret_name"

    if [[ -n "$secret_value" ]]; then
        # Add secret with provided value
        echo "$secret_value" | pass insert --echo "$full_path"
    else
        # Prompt for secret value
        pass insert "$full_path"
    fi

    if [[ $? -eq 0 ]]; then
        success "Secret added: $secret_name"
    else
        error "Failed to add secret: $secret_name"
        return 1
    fi
}

# Get a secret value
get_secret() {
    local secret_name="$1"
    local full_path="${PASS_REPO_NAME}/${secret_name}"

    if ! pass show "$full_path" 2>/dev/null; then
        return 1
    fi
}

# List all secrets
list_secrets() {
    echo ""
    echo "Stored Secrets:"
    echo ""

    local pass_path
    pass_path="${PASSWORD_STORE_DIR:-$HOME/.password-store}"

    if [[ ! -d "$pass_path/$PASS_REPO_NAME" ]]; then
        echo "No secrets repository found."
        echo "Initialize with: ./install.sh --init-secrets"
        return 0
    fi

    pass show "$PASS_REPO_NAME" 2>/dev/null || {
        echo "No secrets found."
        return 0
    }
}

# Delete a secret
delete_secret() {
    local secret_name="$1"
    local full_path="${PASS_REPO_NAME}/${secret_name}"

    if [[ -z "$secret_name" ]]; then
        error "Secret name is required"
        return 1
    fi

    if ! pass show "$full_path" &>/dev/null; then
        error "Secret not found: $secret_name"
        return 1
    fi

    if ! confirm "Delete secret '$secret_name'?"; then
        log "Deletion cancelled"
        return 0
    fi

    pass rm "$full_path"
    success "Secret deleted: $secret_name"
}

# ============================================================================
# DIRENV INTEGRATION
# ============================================================================

# Generate .envrc file for a directory
generate_direnv() {
    local target_dir="$1"
    local secrets=("${@:2}")

    if [[ -z "$target_dir" ]]; then
        error "Target directory is required"
        return 1
    fi

    if [[ ! -d "$target_dir" ]]; then
        error "Directory not found: $target_dir"
        return 1
    fi

    local envrc_file="${target_dir}/.envrc"

    log "Generating .envrc for: $target_dir"

    # Create .envrc header
    cat > "$envrc_file" << 'EOF'
# Generated by dotfiles installer
# DO NOT edit manually - use ./install.sh --add-secret-to-direnv

EOF

    # Add secret exports
    for secret_name in "${secrets[@]}"; do
        local full_path="${PASS_REPO_NAME}/${secret_name}"
        local env_var_name
        env_var_name=$(echo "$secret_name" | tr '[:lower:]' '[:upper:]' | tr '-' '_')

        echo "export ${env_var_name}=\"\$(pass show \"$full_path\" 2>/dev/null || echo '')\"" >> "$envrc_file"
        log "Added: $env_var_name"
    done

    # Allow direnv
    if command -v direnv &>/dev/null; then
        direnv allow "$target_dir"
        success ".envrc generated and allowed"
    else
        warn "direnv not found. Install with: pacman -S direnv"
        log "After installing direnv, run: direnv allow $target_dir"
    fi

    success "Generated: $envrc_file"
}

# Add secret to existing .envrc
add_secret_to_direnv() {
    local target_dir="$1"
    local secret_name="$2"

    if [[ -z "$target_dir" || -z "$secret_name" ]]; then
        error "Target directory and secret name are required"
        return 1
    fi

    local envrc_file="${target_dir}/.envrc"
    local full_path="${PASS_REPO_NAME}/${secret_name}"
    local env_var_name
    env_var_name=$(echo "$secret_name" | tr '[:lower:]' '[:upper:]' | tr '-' '_')

    # Create .envrc if it doesn't exist
    if [[ ! -f "$envrc_file" ]]; then
        generate_direnv "$target_dir" "$secret_name"
        return 0
    fi

    # Check if secret already exists in .envrc
    if grep -q "export ${env_var_name}=" "$envrc_file"; then
        warn "Secret already in .envrc: $secret_name"
        return 0
    fi

    # Add secret export to .envrc
    echo "export ${env_var_name}=\"\$(pass show \"$full_path\" 2>/dev/null || echo '')\"" >> "$envrc_file"

    # Allow direnv
    if command -v direnv &>/dev/null; then
        direnv allow "$target_dir"
    fi

    success "Added secret to .envrc: $secret_name"
}

# ============================================================================
# ITEM SECRETS INTEGRATION
# ============================================================================

# Setup secrets for a specific item (e.g., Claude Code)
setup_item_secrets() {
    local item_name="$1"

    log "Setting up secrets for: $item_name"

    local item_var="ITEM_${item_name}"
    local secrets
    secrets=$(get_item_value "$item_var" "secrets" 2>/dev/null)

    if [[ -z "$secrets" ]]; then
        log "No secrets required for $item_name"
        return 0
    fi

    local config_path
    config_path=$(get_item_value "$item_var" "config_path")
    config_path="$(eval echo "$config_path")"

    # Convert comma-separated secrets to array
    IFS=',' read -ra secret_list <<< "$secrets"

    # Generate .envrc for the item's config directory
    if [[ -d "$config_path" ]]; then
        generate_direnv "$config_path" "${secret_list[@]}"
    else
        warn "Config directory not found: $config_path"
    fi
}

# Check if item has required secrets
check_item_secrets() {
    local item_name="$1"

    local item_var="ITEM_${item_name}"
    local secrets
    secrets=$(get_item_value "$item_var" "secrets" 2>/dev/null)

    if [[ -z "$secrets" ]]; then
        return 0
    fi

    log "Checking secrets for: $item_name"

    # Convert comma-separated secrets to array
    IFS=',' read -ra secret_list <<< "$secrets"

    local missing=()
    for secret_name in "${secret_list[@]}"; do
        # Trim whitespace
        secret_name=$(echo "$secret_name" | xargs)

        if ! get_secret "$secret_name" &>/dev/null; then
            missing+=("$secret_name")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        warn "Missing secrets for $item_name:"
        for secret in "${missing[@]}"; do
            echo "  - $secret"
        done
        echo ""
        echo "Add secrets with:"
        echo "  ./install.sh --add-secret $secret_name"
        return 1
    fi

    success "All secrets present for $item_name"
    return 0
}

# ============================================================================
# SECRETS VALIDATION
# ============================================================================

# Validate all required secrets for installed items
validate_all_secrets() {
    log "Validating secrets for all installed items..."

    local errors=0

    for item in $(get_all_items); do
        if get_item_status "$item"; then
            if ! check_item_secrets "$item"; then
                ((errors++))
            fi
        fi
    done

    if [[ $errors -eq 0 ]]; then
        success "All secrets validated"
    else
        warn "Found $errors item(s) with missing secrets"
    fi

    return $errors
}

# ============================================================================
# EXPORT FUNCTIONS
# ============================================================================

export -f init_secrets
export -f add_secret get_secret list_secrets delete_secret
export -f generate_direnv add_secret_to_direnv
export -f setup_item_secrets check_item_secrets validate_all_secrets
